"""Database models for trade tracking.

This module provides Python dataclasses that mirror the PostgreSQL
tables used in the trade tracking database schema. These models
enable type-safe interaction with the database.
"""

from dataclasses import dataclass, field
from datetime import datetime
from decimal import Decimal
from typing import Optional
from uuid import UUID

from src.db import OrderSide, TradeSide, TradeStatus


@dataclass
class Wallet:
    """Represents a trading wallet.

    A wallet stores information about an Ethereum address used for trading,
    including configuration for signature type and activation status.

    Attributes:
        id: Unique identifier (UUID). Auto-generated by database if not provided.
        address: Ethereum address in 0x format (42 characters).
        name: Human-readable identifier for the wallet.
        signature_type: Wallet signature type: 0=EOA, 1=Magic, 2=Browser.
        is_active: Whether this wallet is currently active for trading.
        created_at: Timestamp when the wallet record was created.
        updated_at: Timestamp when the wallet record was last updated.
    """

    address: str  # Ethereum address (0x + 40 hex chars)
    id: Optional[UUID] = None
    name: Optional[str] = None
    signature_type: int = 0  # 0=EOA, 1=Magic, 2=Browser
    is_active: bool = True
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def __str__(self) -> str:
        """Human-readable string representation."""
        name_part = f" ({self.name})" if self.name else ""
        return f"Wallet({self.address}{name_part})"


@dataclass
class Market:
    """Represents a prediction market.

    A market stores information about a Polymarket condition, including
    its question, end date, and resolution status for redemption tracking.

    Attributes:
        id: Unique identifier (UUID). Auto-generated by database if not provided.
        condition_id: Unique Polymarket condition ID for the market.
        question: Market question or title.
        end_date: Market end date/time.
        resolved: Whether the market has been resolved.
        winning_side: Resolved outcome: 'YES', 'NO', or None if unresolved.
        resolution_price: Final price at resolution (0.0 to 1.0).
        created_at: Timestamp when the market record was created.
        updated_at: Timestamp when the market record was last updated.
    """

    condition_id: str  # Polymarket condition ID
    id: Optional[UUID] = None
    question: Optional[str] = None
    end_date: Optional[datetime] = None
    resolved: bool = False
    winning_side: Optional[str] = None  # 'YES' or 'NO'
    resolution_price: Optional[Decimal] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def __str__(self) -> str:
        """Human-readable string representation."""
        status = "resolved" if self.resolved else "open"
        question_preview = (
            f'"{self.question[:30]}..."' if self.question and len(self.question) > 30
            else f'"{self.question}"' if self.question
            else "No question"
        )
        return f"Market({question_preview}, {status})"


@dataclass
class Trade:
    """Represents a trade record.

    A trade stores all information about an order and its lifecycle,
    including P&L tracking for tax reporting and position management.

    Attributes:
        id: Unique identifier (UUID). Auto-generated by database if not provided.
        wallet_id: Reference to the wallet that placed this trade.
        market_id: Reference to the market being traded.
        order_id: External order ID from CLOB API.
        token_id: CLOB token ID (long hash) required for order placement.
        side: Outcome token being traded: YES or NO.
        order_type: Order direction: BUY or SELL.
        quantity: Original order quantity in token units.
        filled_quantity: Quantity filled so far (for partial fills).
        limit_price: Limit price for the order (0.01 to 0.99).
        avg_fill_price: Volume-weighted average fill price.
        exit_price: Price when position was closed.
        cost_basis_usd: Total cost of position in USD.
        proceeds_usd: Total proceeds from closing position in USD.
        realized_pnl: Realized profit or loss in USD.
        neg_risk: Whether this is a negative risk market.
        status: Current status: open, filled, partially_filled, cancelled, closed.
        created_at: Timestamp when the trade was created.
        filled_at: Timestamp when the order was filled.
        closed_at: Timestamp when the position was closed.
        updated_at: Timestamp when the trade record was last updated.
    """

    # Required fields (no defaults)
    wallet_id: UUID
    market_id: UUID
    token_id: str  # CLOB token ID for the outcome
    side: TradeSide  # YES or NO
    order_type: OrderSide  # BUY or SELL
    quantity: Decimal  # Original order quantity
    limit_price: Decimal  # Order limit price (0.01 to 0.99)

    # Optional identifier fields
    id: Optional[UUID] = None
    order_id: Optional[str] = None  # External order ID from CLOB

    # Quantity tracking
    filled_quantity: Decimal = field(default_factory=lambda: Decimal("0"))

    # Optional price fields
    avg_fill_price: Optional[Decimal] = None
    exit_price: Optional[Decimal] = None

    # P&L tracking
    cost_basis_usd: Optional[Decimal] = None
    proceeds_usd: Optional[Decimal] = None
    realized_pnl: Optional[Decimal] = None

    # Flags
    neg_risk: bool = False
    status: TradeStatus = TradeStatus.OPEN

    # Timestamps
    created_at: Optional[datetime] = None
    filled_at: Optional[datetime] = None
    closed_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None

    def __str__(self) -> str:
        """Human-readable string representation."""
        return (
            f"Trade({self.order_type.value} {self.side.value} "
            f"@ ${self.limit_price:.2f}, {self.status.value})"
        )

    @property
    def is_open(self) -> bool:
        """Check if the trade is still open."""
        return self.status in (TradeStatus.OPEN, TradeStatus.PARTIALLY_FILLED)

    @property
    def is_complete(self) -> bool:
        """Check if the trade has been fully filled."""
        return self.status in (TradeStatus.FILLED, TradeStatus.CLOSED)

    @property
    def fill_percentage(self) -> Decimal:
        """Calculate the percentage of the order that has been filled."""
        if self.quantity == 0:
            return Decimal("0")
        return (self.filled_quantity / self.quantity) * Decimal("100")


__all__ = ["Wallet", "Market", "Trade"]
